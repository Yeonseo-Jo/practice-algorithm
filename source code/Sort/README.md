## Sort (정렬)

### 1. 삽입 정렬 (Insertion Sort):

- 배열을 두 부분으로 나누어, 정렬된 부분에 새로운 요소를 삽입하는 방식으로 정렬
- 비교적 간단하고 적은 데이터에서 효율적
- 시간복잡도: `O(n²)` / 최선의 경우 O(n) (이미 정렬된 경우)

<br/>

### 2. 병합 정렬 (Merge Sort):

- 배열을 반으로 나누고, 각 부분을 재귀적으로 정렬한 후, 두 배열을 병합하여 최종 정렬
- 안정적인 정렬이며 대량의 데이터에 유리
- 시간복잡도: `O(n log n)`

<br/>

### 3. 버블 정렬 (Bubble Sort):

- 배열을 반복적으로 순차적으로 비교하여 인접한 두 요소를 교환하는 방식
- 단순하지만 비효율적이며, 최적화 없이 사용하면 느림
- 시간복잡도: `O(n²)` / 최선의 경우 O(n) (이미 정렬된 경우)

<br/>

### 4. 힙 정렬 (Heap Sort):

- 배열을 힙(완전 이진 트리 형태) 구조로 변환한 후, 가장 큰(혹은 작은) 요소를 하나씩 추출하여 정렬.
- 안정성은 보장되지 않지만 대용량 데이터에 적합하며, 공간 복잡도가 낮음
- 시간복잡도: `O(n log n)`

<br/>

### 5. 위상 정렬 (Topological Sort):

- 일의 순서가 있는 작업을 순서에 맞춰 정렬하는 알고리즘
- 접근 방식 : 각 노드마다 진입차수(indegree)를 계산하여, indegree가 0인것부터 큐에 넣어 처리
- 시간 복잡도 : `O(|V| + |E|)` -> 모든 정점과 간선을 한 번씩 지나므로

<br/>

### 6. 계수 정렬 (Counting Sort)

- 특정한 조건에 부합할 때 사용할 수 있는 알고리즘으로, 데이터의 빈도수로 정렬함
- 매우 빠른 정렬 알고리즘 / 단, 데이터의 크기 범위가 제한되어 있음 (정수 형태로 표현 가능할 때만 사용 가능)

  -> 계수 정렬을 이요할 때 모든 범위를 담을 수 있는 크기의 배열을 사용하기 때문임.

  -> 빈도수 배열에 저장할 값의 범위가 듬성듬성 잇거나, 음수가 있으면 계수 정렬하기 어려움

- 시간 복잡도 : `O(N + K)`

  -> (모든 데이터가 양의 정수일 때) 데이터의 개수가 N, 데이터의 최댓값이 K일 때

  <br/>

### 7. Array.prototype.sort()

- js 내장 정렬 메서드
- 사용하는 알고리즘 : `TimeSort`
  - TimeSort : mergeSort + insertionSort (짧은 배열에서는 삽입 정렬 / 긴 배열에서는 병합 정렬 이미 정렬된 부분 찾아 최적화 된 방식으로 처리)
- `compareFunction` : 배열의 정렬 순서 결정, 반환 값에 따라 정렬

  - compareFunction 제공 안하면 문자열 변환 후 유니코드 코드 포인터 순서로 문자열 비교 정렬
  - 반환 값 음수 : a(배열 첫번째 요소)가 b(배열 두번째 요소)보다 먼저 오도록
  - 반환 값 양수 : b가 a보다 먼저 오도록
  - 0 : a와 b 순서 안바꿈 (같은 값은 기존 순서 유지)

    => arr.sort((a, b) => a - b) : 오름차순 정렬

    => arr.sort((a, b) => b - a) : 내림차순 정렬

- 시간 복잡도 : `O(n log n)` / 최선의 경우 O(n) (이미 정렬된 경우)

<br/>
<hr/>

### 8. 정렬 알고리즘의 시간 복잡도 비교

| 정렬 알고리즘         | 최악의 경우 | 최선의 경우 | 특징                                                                |
| --------------------- | ----------- | ----------- | ------------------------------------------------------------------- |
| **삽입 정렬**         | O(n²)       | O(n)        | 데이터가 이미 정렬된 경우 빠르게 정렬 가능.                         |
| **병합 정렬**         | O(n log n)  | O(n log n)  | 안정적인 정렬. 병합 과정에서 추가적인 메모리가 필요함.              |
| **버블 정렬**         | O(n²)       | O(n)        | 데이터가 거의 정렬되어 있을 때 최고의 성능을 발휘함.                |
| **힙 정렬**           | O(n log n)  | O(n log n)  | 추가 메모리 공간이 필요하지 않으며, 불안정한 정렬.                  |
| **위상 정렬**         | O(V + E)    | O(V + E)    | 작업의 순서가 존재할 때 사용되는 알고리즘 (V=정점, E=간선).         |
| **계수 정렬**         | O(n + k)    | O(n + k)    | 데이터의 범위가 작고, 정수가 아닌 데이터에는 사용할 수 없음.        |
| **JavaScript sort()** | O(n log n)  | O(n)        | Timsort 알고리즘을 사용. 데이터가 정렬된 상태에서는 더 빠르게 동작. |

**참고**:

- `n`: 원소의 개수
- `k`: 원소 값의 범위
- `V`: 그래프의 정점 개수
- `E`: 그래프의 간선 개수

### 9. 기타 정렬 관련 내용

**(1) 비교 정렬 vs 비비교 정렬**

- `비교 정렬` : 원소 간 대소 관계 값을 비교하며 진행하는 정렬, 데이터에 의존하지 않고 정렬함
  => ex. 삽입, 병합, 힙 정렬
  => 비교 기반 알고리즘의 성능 하한(최대 성능, 한계)는 O(NlogN)
- `비비교 정렬` : 데이터에 의존하는 정렬
  => ex. 계수 정렬
  => 데이터 자체에 의존하는 정렬방식이므로 연산 횟수 정확히 측정 할 수 없어 하한 자체가 의미가 없음

**(2) 안정적인 정렬**

- 정렬에서 `안정적이다` : 동일한 우선순위를 가진 원소들의 상대적인 순서가 정렬 후에도 보존 됨
